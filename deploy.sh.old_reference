#!/bin/bash

# ChatBot API 完整部署脚本
# 支持域名和 Let's Encrypt SSL 证书
# 适用于 Ubuntu 20.04, Python 3.10.18

set -e  # 遇到错误立即退出

# ==================== 配置变量 ====================
PROJECT_NAME="chatbot-api"
PROJECT_DIR="/root/dylan/ChatGPT-Telegram-Bot/CheapBuy"
PUBLIC_IP="8.163.12.28"
DOMAIN="baloonet.tech"  # 如果没有域名，留空
APP_PORT="8000"          # FastAPI 内部运行端口
PUBLIC_PORT="17432"      # 对外服务端口
NGINX_HTTP_PORT="80"     # HTTP 端口
NGINX_HTTPS_PORT="443"   # HTTPS 端口
EMAIL="dogechat@163.com"  # Let's Encrypt 通知邮箱
PYTHON_VERSION="3.10"

# ==================== 颜色输出 ====================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ==================== 日志函数 ====================
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $1"
}

# ==================== 检查函数 ====================

# 启动 Docker 服务
start_docker() {
    log_info "检查 Docker 服务..."
    
    if systemctl is-active --quiet docker; then
        log_info "Docker 服务已经在运行"
    else
        log_info "启动 Docker 服务..."
        sudo systemctl start docker
        sudo systemctl enable docker
        sleep 3
    fi
}

# 启动 PostgreSQL 容器
start_postgresql_container() {
    log_info "检查 PostgreSQL 容器..."
    
    # 获取 PostgreSQL 容器名称（可能的名称）
    PG_CONTAINERS=("postgres" "postgresql" "chatbot-postgres" "chatbot_postgres")
    PG_CONTAINER=""
    
    # 查找正在运行的 PostgreSQL 容器
    for container in "${PG_CONTAINERS[@]}"; do
        if docker ps -a --format "table {{.Names}}" | grep -q "^${container}$"; then
            PG_CONTAINER=$container
            break
        fi
    done
    
    if [ -z "$PG_CONTAINER" ]; then
        log_error "未找到 PostgreSQL 容器，请确认容器名称"
        log_info "当前容器列表："
        docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
        
        # 提示创建新容器
        log_warn "如果需要创建新的 PostgreSQL 容器，请运行："
        echo "docker run -d --name postgres \\"
        echo "  -e POSTGRES_PASSWORD=your_password \\"
        echo "  -e POSTGRES_DB=chatbot_db \\"
        echo "  -p 5432:5432 \\"
        echo "  -v postgres_data:/var/lib/postgresql/data \\"
        echo "  postgres:15"
        return 1
    fi
    
    # 检查容器状态
    if docker ps --format "{{.Names}}" | grep -q "^${PG_CONTAINER}$"; then
        log_info "PostgreSQL 容器 '${PG_CONTAINER}' 已经在运行"
    else
        log_info "启动 PostgreSQL 容器 '${PG_CONTAINER}'..."
        docker start ${PG_CONTAINER}
        sleep 5
    fi
    
    # 等待 PostgreSQL 完全启动
    log_info "等待 PostgreSQL 就绪..."
    for i in {1..30}; do
        if docker exec ${PG_CONTAINER} pg_isready &> /dev/null; then
            log_info "PostgreSQL 已就绪"
            return 0
        fi
        sleep 1
    done
    
    log_error "PostgreSQL 启动超时"
    return 1
}

# 启动 Redis 容器
start_redis_container() {
    log_info "检查 Redis 容器..."
    
    # 获取 Redis 容器名称（可能的名称）
    REDIS_CONTAINERS=("redis" "chatbot-redis" "chatbot_redis")
    REDIS_CONTAINER=""
    
    # 查找 Redis 容器
    for container in "${REDIS_CONTAINERS[@]}"; do
        if docker ps -a --format "table {{.Names}}" | grep -q "^${container}$"; then
            REDIS_CONTAINER=$container
            break
        fi
    done
    
    if [ -z "$REDIS_CONTAINER" ]; then
        log_error "未找到 Redis 容器，请确认容器名称"
        
        # 提示创建新容器
        log_warn "如果需要创建新的 Redis 容器，请运行："
        echo "docker run -d --name redis \\"
        echo "  -p 6379:6379 \\"
        echo "  -v redis_data:/data \\"
        echo "  redis:7-alpine \\"
        echo "  redis-server --appendonly yes"
        return 1
    fi
    
    # 检查容器状态
    if docker ps --format "{{.Names}}" | grep -q "^${REDIS_CONTAINER}$"; then
        log_info "Redis 容器 '${REDIS_CONTAINER}' 已经在运行"
    else
        log_info "启动 Redis 容器 '${REDIS_CONTAINER}'..."
        docker start ${REDIS_CONTAINER}
        sleep 3
    fi
    
    # 测试 Redis 连接
    log_info "测试 Redis 连接..."
    if docker exec ${REDIS_CONTAINER} redis-cli ping &> /dev/null; then
        log_info "Redis 连接成功"
        return 0
    else
        log_error "Redis 连接失败"
        return 1
    fi
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "此脚本需要 root 权限运行"
        log_info "请使用: sudo $0"
        exit 1
    fi
}

check_project() {
    if [ ! -d "$PROJECT_DIR" ]; then
        log_error "项目目录不存在: $PROJECT_DIR"
        exit 1
    fi
    
    if [ ! -f "$PROJECT_DIR/app/main.py" ]; then
        log_error "未找到 app/main.py 文件"
        exit 1
    fi
    
    log_info "项目目录检查通过"
}

check_domain_dns() {
    if [ -n "$DOMAIN" ]; then
        log_info "检查域名 DNS 配置..."
        
        # 检查域名解析
        resolved_ip=$(dig +short $DOMAIN | tail -n1)
        if [ "$resolved_ip" != "$PUBLIC_IP" ]; then
            log_warning "域名 $DOMAIN 未解析到 $PUBLIC_IP (当前解析到: $resolved_ip)"
            log_warning "请确保 DNS A 记录已正确配置"
            read -p "是否继续？(y/n) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                exit 1
            fi
        else
            log_info "域名 DNS 配置正确"
        fi
    fi
}

# ==================== 系统配置 ====================
update_system() {
    log_step "更新系统包..."
    
    # 检查是否需要更新
    last_update_file="/var/lib/apt/periodic/update-success-stamp"
    if [ -f "$last_update_file" ]; then
        last_update=$(stat -c %Y "$last_update_file")
        current_time=$(date +%s)
        time_diff=$((current_time - last_update))
        # 如果上次更新在24小时内，跳过
        if [ $time_diff -lt 86400 ]; then
            log_info "系统在24小时内已更新，跳过更新步骤"
            return
        fi
    fi
    
    apt-get update
    apt-get upgrade -y
}

install_dependencies() {
    log_step "安装系统依赖..."
    
    # 检查已安装的包
    packages_to_install=()
    for pkg in nginx ufw supervisor curl git net-tools dnsutils snapd; do
        if ! dpkg -l | grep -q "^ii  $pkg "; then
            packages_to_install+=($pkg)
        fi
    done
    
    if [ ${#packages_to_install[@]} -eq 0 ]; then
        log_info "所有系统依赖已安装"
    else
        log_info "安装缺失的包: ${packages_to_install[*]}"
        apt-get install -y "${packages_to_install[@]}"
    fi
    
    # 启用 snapd
    systemctl enable --now snapd.socket
    
    log_info "系统依赖安装完成"
}

# ==================== Python 依赖修复 ====================
fix_python_dependencies() {
    log_step "修复 Python 依赖问题..."
    
    # 创建依赖修复标记文件
    DEPS_FIXED_FLAG="${PROJECT_DIR}/.deps_fixed_v2"
    
    if [ -f "$DEPS_FIXED_FLAG" ]; then
        log_info "Python 依赖已修复，跳过此步骤"
        return
    fi
    
    log_info "开始修复 OpenSSL 相关依赖..."
    
    # 1. 卸载冲突的包
    log_info "卸载可能冲突的包..."
    pip3 uninstall -y pyOpenSSL cryptography urllib3 requests google-generativeai || true
    
    # 2. 清理 pip 缓存
    log_info "清理 pip 缓存..."
    pip3 cache purge
    
    # 3. 更新 pip、setuptools 和 wheel
    log_info "更新 pip 工具链..."
    python3 -m pip install --upgrade pip setuptools wheel
    
    # 4. 安装系统级 OpenSSL 开发包
    log_info "安装系统 OpenSSL 开发包..."
    apt-get install -y libssl-dev libffi-dev python3-dev
    
    # 5. 按正确顺序重新安装包
    log_info "重新安装 Python 包..."
    
    # 先安装基础加密包
    pip3 install --force-reinstall --no-cache-dir \
        "cryptography>=41.0.0" \
        "pyOpenSSL>=23.2.0"
    
    # 安装网络请求相关包
    pip3 install --force-reinstall --no-cache-dir \
        "urllib3>=2.0.0,<3.0.0" \
        "requests>=2.31.0" \
        "certifi>=2023.7.22"
    
    # 安装 Google AI 相关包
    pip3 install --force-reinstall --no-cache-dir \
        "google-auth>=2.23.0" \
        "google-api-core>=2.11.0" \
        "google-generativeai>=0.3.0"
    
    # 6. 如果项目有 requirements.txt，安装其他依赖
    if [ -f "${PROJECT_DIR}/requirements.txt" ]; then
        log_info "安装项目其他依赖..."
        pip3 install -r "${PROJECT_DIR}/requirements.txt" --no-deps
        pip3 install -r "${PROJECT_DIR}/requirements.txt"
    fi
    
    # 创建标记文件
    touch "$DEPS_FIXED_FLAG"
    
    log_info "Python 依赖修复完成"
}

# ==================== Certbot 安装 ====================
install_certbot() {
    log_step "安装 Certbot..."
    
    # 检查是否已安装
    if command -v certbot &> /dev/null; then
        log_info "Certbot 已安装"
        return
    fi
    
    # 先移除可能存在的旧版本
    apt-get remove -y certbot python3-certbot-nginx || true
    
    # 使用 snap 安装最新版
    snap install core
    snap refresh core
    snap install --classic certbot
    
    # 创建符号链接
    ln -sf /snap/bin/certbot /usr/bin/certbot
    
    # 验证安装
    if certbot --version; then
        log_info "Certbot 安装成功"
    else
        log_error "Certbot 安装失败"
        exit 1
    fi
}

# ==================== 防火墙配置 ====================
configure_firewall() {
    log_step "配置防火墙..."
    
    # 检查防火墙状态
    if ufw status | grep -q "Status: active"; then
        log_info "防火墙已激活，更新规则..."
    else
        log_info "配置新的防火墙规则..."
    fi
    
    # 允许基本服务
    ufw allow 22/tcp comment 'SSH'
    ufw allow 80/tcp comment 'HTTP'
    ufw allow 443/tcp comment 'HTTPS'
    ufw allow ${PUBLIC_PORT}/tcp comment 'ChatBot API Public Port'
    
    # 启用防火墙
    echo "y" | ufw enable
    
    # 显示防火墙状态
    ufw status verbose
    
    log_info "防火墙配置完成"
}

# ==================== Systemd 服务配置 ====================
create_systemd_service() {
    log_step "创建 Systemd 服务..."
    
    # 创建日志目录
    mkdir -p /var/log/${PROJECT_NAME}
    
    # 创建服务文件
    cat > /etc/systemd/system/${PROJECT_NAME}.service <<EOF
[Unit]
Description=ChatBot API Service
After=network.target postgresql.service redis.service

[Service]
Type=simple
User=root
WorkingDirectory=${PROJECT_DIR}
Environment="PATH=/usr/bin:/usr/local/bin"
Environment="PYTHONPATH=${PROJECT_DIR}"
Environment="PYTHONUNBUFFERED=1"
ExecStart=/usr/bin/python${PYTHON_VERSION} -m uvicorn app.main:app --host 0.0.0.0 --port ${APP_PORT} --workers 1
Restart=always
RestartSec=10
StandardOutput=append:/var/log/${PROJECT_NAME}/stdout.log
StandardError=append:/var/log/${PROJECT_NAME}/stderr.log

# 安全限制
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
EOF

    # 重新加载 systemd
    systemctl daemon-reload
    
    # 启动并启用服务
    systemctl enable ${PROJECT_NAME}
    systemctl restart ${PROJECT_NAME}
    
    # 等待服务启动
    sleep 5
    
    # 检查服务状态
    if systemctl is-active --quiet ${PROJECT_NAME}; then
        log_info "Systemd 服务创建并启动成功"
    else
        log_error "服务启动失败，请检查日志: journalctl -u ${PROJECT_NAME} -f"
        log_error "或查看: tail -f /var/log/${PROJECT_NAME}/stderr.log"
        exit 1
    fi
}

# ==================== Nginx 配置 ====================
configure_nginx_initial() {
    log_step "配置 Nginx (初始配置)..."
    
    # 备份默认配置
    if [ -f /etc/nginx/sites-enabled/default ]; then
        mv /etc/nginx/sites-enabled/default /etc/nginx/sites-enabled/default.bak
    fi
    
    # 根据是否有域名选择配置
    if [ -z "$DOMAIN" ]; then
        SERVER_NAME=$PUBLIC_IP
    else
        SERVER_NAME="$DOMAIN www.$DOMAIN"
    fi
    
    # 确保 webroot 目录存在
    mkdir -p /var/www/html/.well-known/acme-challenge
    chmod -R 755 /var/www/html
    
    # 创建初始 HTTP 配置（用于 Let's Encrypt 验证）
    cat > /etc/nginx/sites-available/${PROJECT_NAME} <<EOF
# HTTP 服务器
server {
    listen 80;
    listen [::]:80;
    server_name ${SERVER_NAME};
    
    # Let's Encrypt 验证目录 - 优先处理
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
        # 确保文件可访问
        try_files \$uri =404;
    }
    
    # API 代理（临时）
    location / {
        proxy_pass http://127.0.0.1:${APP_PORT};
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}

# 端口 ${PUBLIC_PORT} 服务器（临时无 SSL）
server {
    listen ${PUBLIC_PORT};
    listen [::]:${PUBLIC_PORT};
    server_name ${SERVER_NAME};
    
    client_max_body_size 100M;
    
    location / {
        proxy_pass http://127.0.0.1:${APP_PORT};
        proxy_http_version 1.1;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_buffering off;
    }
    
    location /ws {
        proxy_pass http://127.0.0.1:${APP_PORT}/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_read_timeout 86400;
    }
}
EOF

    # 启用站点
    ln -sf /etc/nginx/sites-available/${PROJECT_NAME} /etc/nginx/sites-enabled/
    
    # 测试并重启 Nginx
    nginx -t && systemctl restart nginx
    systemctl enable nginx
    
    log_info "Nginx 初始配置完成"
}

# ==================== SSL 证书配置 ====================
configure_ssl() {
    log_step "配置 SSL 证书..."
    
    if [ -z "$DOMAIN" ]; then
        log_warning "未设置域名，将使用自签名证书"
        configure_self_signed_ssl
    else
        log_info "使用 Let's Encrypt 申请证书"
        configure_lets_encrypt
    fi
}

configure_self_signed_ssl() {
    log_info "生成自签名证书..."
    
    mkdir -p /etc/nginx/ssl
    
    # 检查证书是否已存在
    if [ -f "/etc/nginx/ssl/${PROJECT_NAME}.crt" ] && [ -f "/etc/nginx/ssl/${PROJECT_NAME}.key" ]; then
        log_info "自签名证书已存在，跳过生成"
    else
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/nginx/ssl/${PROJECT_NAME}.key \
            -out /etc/nginx/ssl/${PROJECT_NAME}.crt \
            -subj "/C=CN/ST=State/L=City/O=Organization/CN=${PUBLIC_IP}"
    fi
    
    # 更新 Nginx 配置
    configure_nginx_final "/etc/nginx/ssl/${PROJECT_NAME}.crt" "/etc/nginx/ssl/${PROJECT_NAME}.key"
    
    log_warning "已配置自签名证书，浏览器会显示安全警告"
}

configure_lets_encrypt() {
    log_info "配置 Let's Encrypt 证书..."
    
    # 确保 webroot 目录存在并有正确权限
    mkdir -p /var/www/html/.well-known/acme-challenge
    chmod -R 755 /var/www/html
    
    # 创建测试文件验证 webroot 可访问
    echo "test" > /var/www/html/.well-known/acme-challenge/test.txt
    
    # 检查证书是否已存在
    if [ -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
        log_info "证书已存在，跳过申请步骤"
        
        # 直接使用现有证书更新 Nginx 配置
        configure_nginx_final \
            "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" \
            "/etc/letsencrypt/live/${DOMAIN}/privkey.pem"
        
        # 确保自动续期已启用
        if systemctl is-enabled snap.certbot.renew.timer &>/dev/null; then
            log_info "证书自动续期已启用"
        else
            systemctl enable snap.certbot.renew.timer
            systemctl start snap.certbot.renew.timer
            log_info "已启用证书自动续期"
        fi
    else
        log_info "申请新证书..."
        
        # 申请新证书
        certbot certonly --webroot \
            -w /var/www/html \
            -d ${DOMAIN} \
            -d www.${DOMAIN} \
            --non-interactive \
            --agree-tos \
            --email ${EMAIL}
        
        # 检查证书是否申请成功
        if [ -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
            log_info "证书申请成功！"
            
            # 更新 Nginx 配置
            configure_nginx_final \
                "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" \
                "/etc/letsencrypt/live/${DOMAIN}/privkey.pem"
            
            # 设置自动续期
            systemctl enable snap.certbot.renew.timer
            systemctl start snap.certbot.renew.timer
            
            # 备用 cron 任务
            (crontab -l 2>/dev/null || true; echo "0 3 * * * /snap/bin/certbot renew --quiet --post-hook 'systemctl reload nginx'") | crontab -
            
        else
            log_error "证书申请失败"
            exit 1
        fi
    fi
    
    # 清理测试文件
    rm -f /var/www/html/.well-known/acme-challenge/test.txt
}

# ==================== Nginx 最终配置 ====================
configure_nginx_final() {
    local cert_path=$1
    local key_path=$2
    
    log_info "更新 Nginx 最终配置..."
    
    if [ -z "$DOMAIN" ]; then
        SERVER_NAME=$PUBLIC_IP
    else
        SERVER_NAME="$DOMAIN www.$DOMAIN"
    fi
    
    cat > /etc/nginx/sites-available/${PROJECT_NAME} <<EOF
# HTTP 服务器 - 重定向到 HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name ${SERVER_NAME};
    
    # Let's Encrypt 验证目录 - 必须保留用于证书续期
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
        try_files \$uri =404;
    }
    
    location / {
        return 301 https://\$host:${PUBLIC_PORT}\$request_uri;
    }
}

# HTTPS 服务器 - 端口 ${PUBLIC_PORT}
server {
    listen ${PUBLIC_PORT} ssl http2;
    listen [::]:${PUBLIC_PORT} ssl http2;
    server_name ${SERVER_NAME};
    
    # SSL 证书
    ssl_certificate ${cert_path};
    ssl_certificate_key ${key_path};
    
    # SSL 优化
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 安全头部
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # 客户端配置
    client_max_body_size 100M;
    
    # 代理超时
    proxy_connect_timeout 6000s;
    proxy_send_timeout 6000s;
    proxy_read_timeout 30000s;
    
    # API 代理
    location / {
        proxy_pass http://127.0.0.1:${APP_PORT};
        proxy_http_version 1.1;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        
        # 流式响应支持
        proxy_buffering off;
        proxy_cache off;
        proxy_set_header Connection '';
        proxy_set_header Cache-Control 'no-cache';
        proxy_set_header X-Accel-Buffering 'no';
    }
    
    # WebSocket 支持
    location /ws {
        proxy_pass http://127.0.0.1:${APP_PORT}/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_read_timeout 86400;
    }
    
    # 健康检查
    location /health {
        access_log off;
        proxy_pass http://127.0.0.1:${APP_PORT}/health;
    }
}

# 标准 HTTPS 端口 443 - 重定向到自定义端口
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${SERVER_NAME};
    
    ssl_certificate ${cert_path};
    ssl_certificate_key ${key_path};
    
    return 301 https://\$host:${PUBLIC_PORT}\$request_uri;
}
EOF

    # 测试并重启 Nginx
    if nginx -t; then
        systemctl restart nginx
        log_info "Nginx 最终配置完成"
    else
        log_error "Nginx 配置测试失败"
        exit 1
    fi
}

# ==================== 环境配置 ====================
update_env_file() {
    log_step "更新环境配置文件..."
    
    if [ -f "${PROJECT_DIR}/.env" ]; then
        # 备份原文件
        cp ${PROJECT_DIR}/.env ${PROJECT_DIR}/.env.bak.$(date +%Y%m%d_%H%M%S)
        
        # 更新 CORS 配置
        if [ -n "$DOMAIN" ]; then
            # 使用域名
            CORS_ORIGINS="[\"https://${DOMAIN}\",\"https://${DOMAIN}:${PUBLIC_PORT}\",\"https://www.${DOMAIN}\",\"https://www.${DOMAIN}:${PUBLIC_PORT}\"]"
        else
            # 使用 IP
            CORS_ORIGINS="[\"https://${PUBLIC_IP}:${PUBLIC_PORT}\"]"
        fi
        
        # 更新 CORS_ORIGINS
        if grep -q "CORS_ORIGINS=" ${PROJECT_DIR}/.env; then
            sed -i "s|CORS_ORIGINS=.*|CORS_ORIGINS=${CORS_ORIGINS}|g" ${PROJECT_DIR}/.env
        else
            echo "CORS_ORIGINS=${CORS_ORIGINS}" >> ${PROJECT_DIR}/.env
        fi
        
        log_info "环境配置文件已更新"
    else
        log_warning ".env 文件不存在，创建示例文件"
        create_example_env
    fi
}

create_example_env() {
    cat > ${PROJECT_DIR}/.env.example <<EOF
# 基本配置
APP_NAME="ChatBot API"
DEBUG=False
VERSION="1.0.0"

# 安全配置
SECRET_KEY=$(openssl rand -hex 32)
REFRESH_SECRET_KEY=$(openssl rand -hex 32)
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# 数据库配置
DATABASE_URL=postgresql://chatbot:password@localhost/chatbot_db

# Redis配置
REDIS_URL=redis://localhost:6379/0

# CORS配置
CORS_ORIGINS=${CORS_ORIGINS:-[\"*\"]}

# 其他配置请参考 app/config.py
EOF
    
    log_warning "请复制 .env.example 为 .env 并配置必要的参数"
}

# ==================== 监控和日志 ====================
setup_monitoring() {
    log_step "设置监控和日志..."
    
    # 创建日志轮转配置
    cat > /etc/logrotate.d/${PROJECT_NAME} <<EOF
/var/log/${PROJECT_NAME}/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 0640 root root
    sharedscripts
    postrotate
        systemctl reload ${PROJECT_NAME} > /dev/null 2>&1 || true
    endscript
}
EOF
    
    log_info "日志轮转配置完成"
}

# ==================== 服务检查 ====================
check_services() {
    log_step "检查服务状态..."
    
    services=("${PROJECT_NAME}" "nginx")
    
    for service in "${services[@]}"; do
        if systemctl is-active --quiet $service; then
            log_info "✓ $service 运行正常"
        else
            log_error "✗ $service 未运行"
        fi
    done
    
    # 检查端口
    if netstat -tuln | grep -q ":${APP_PORT}"; then
        log_info "✓ 应用端口 ${APP_PORT} 正在监听"
    else
        log_error "✗ 应用端口 ${APP_PORT} 未监听"
    fi
    
    if netstat -tuln | grep -q ":${PUBLIC_PORT}"; then
        log_info "✓ 公网端口 ${PUBLIC_PORT} 正在监听"
    else
        log_error "✗ 公网端口 ${PUBLIC_PORT} 未监听"
    fi
    
    # 检查最近的错误日志
    if [ -f "/var/log/${PROJECT_NAME}/stderr.log" ]; then
        log_info "最近的错误日志："
        tail -n 5 /var/log/${PROJECT_NAME}/stderr.log
    fi
}

# ==================== 部署信息显示 ====================
show_deployment_info() {
    log_step "部署完成！"
    
    echo -e "\n${GREEN}========== 部署信息 ==========${NC}"
    echo -e "${BLUE}项目目录:${NC} ${PROJECT_DIR}"
    echo -e "${BLUE}服务状态:${NC} systemctl status ${PROJECT_NAME}"
    echo -e "${BLUE}查看日志:${NC} journalctl -u ${PROJECT_NAME} -f"
    echo -e "${BLUE}查看错误:${NC} tail -f /var/log/${PROJECT_NAME}/stderr.log"
    
    echo -e "\n${GREEN}========== 访问地址 ==========${NC}"
    if [ -n "$DOMAIN" ]; then
        echo -e "${BLUE}API 文档:${NC} https://${DOMAIN}:${PUBLIC_PORT}/docs"
        echo -e "${BLUE}ReDoc:${NC} https://${DOMAIN}:${PUBLIC_PORT}/redoc"
        echo -e "${BLUE}健康检查:${NC} https://${DOMAIN}:${PUBLIC_PORT}/health"
        echo -e "${BLUE}WebSocket:${NC} wss://${DOMAIN}:${PUBLIC_PORT}/ws"
    else
        echo -e "${BLUE}API 文档:${NC} https://${PUBLIC_IP}:${PUBLIC_PORT}/docs"
        echo -e "${BLUE}ReDoc:${NC} https://${PUBLIC_IP}:${PUBLIC_PORT}/redoc"
        echo -e "${BLUE}健康检查:${NC} https://${PUBLIC_IP}:${PUBLIC_PORT}/health"
        echo -e "${YELLOW}注意:${NC} 使用自签名证书，浏览器会显示安全警告"
    fi
    
    echo -e "\n${GREEN}========== 管理命令 ==========${NC}"
    echo -e "${BLUE}重启服务:${NC} systemctl restart ${PROJECT_NAME}"
    echo -e "${BLUE}查看证书:${NC} certbot certificates"
    echo -e "${BLUE}续期证书:${NC} certbot renew"
    echo -e "${BLUE}修复依赖:${NC} $0 fix-deps"
    
    echo -e "\n${GREEN}========== 客户端连接示例 ==========${NC}"
    if [ -n "$DOMAIN" ]; then
        echo -e "BASE_URL = \"https://${DOMAIN}:${PUBLIC_PORT}\""
    else
        echo -e "BASE_URL = \"https://${PUBLIC_IP}:${PUBLIC_PORT}\""
        echo -e "# 注意：自签名证书需要禁用 SSL 验证（仅测试）"
    fi
}

# ==================== 主函数 ====================
main() {
    log_info "开始部署 ChatBot API..."
    log_info "服务器 IP: ${PUBLIC_IP}"
    log_info "域名: ${DOMAIN:-无}"
    log_info "公网端口: ${PUBLIC_PORT}"
    
    # 执行部署步骤
    start_docker
    start_postgresql_container
    start_redis_container
    check_root
    check_project
    check_domain_dns
    update_system
    install_dependencies
    fix_python_dependencies  # 新增：修复 Python 依赖
    
    # 如果有域名，安装 Certbot
    if [ -n "$DOMAIN" ]; then
        install_certbot
    fi
    
    configure_firewall
    create_systemd_service
    configure_nginx_initial
    configure_ssl
    update_env_file
    setup_monitoring
    check_services
    show_deployment_info
}

# ==================== 脚本入口 ====================
case "${1:-}" in
    "check")
        check_services
        ;;
    "restart")
        systemctl restart ${PROJECT_NAME}
        systemctl reload nginx
        check_services
        ;;
    "update-cert")
        if [ -n "$DOMAIN" ]; then
            log_info "手动续期证书..."
            certbot renew --force-renewal
        else
            log_error "未配置域名，无法更新证书"
        fi
        ;;
    "fix-deps")
        check_root
        check_project
        fix_python_dependencies
        systemctl restart ${PROJECT_NAME}
        check_services
        ;;
    "logs")
        echo "=== 查看服务日志 ==="
        echo "1. 系统日志: journalctl -u ${PROJECT_NAME} -f"
        echo "2. 标准输出: tail -f /var/log/${PROJECT_NAME}/stdout.log"
        echo "3. 错误输出: tail -f /var/log/${PROJECT_NAME}/stderr.log"
        echo ""
        echo "显示最近的错误日志："
        tail -n 50 /var/log/${PROJECT_NAME}/stderr.log
        ;;
    "test-acme")
        log_info "测试 ACME challenge 路径..."
        mkdir -p /var/www/html/.well-known/acme-challenge
        echo "test-acme-challenge" > /var/www/html/.well-known/acme-challenge/test.txt
        chmod -R 755 /var/www/html
        
        if [ -n "$DOMAIN" ]; then
            log_info "测试访问: http://${DOMAIN}/.well-known/acme-challenge/test.txt"
            curl -I http://${DOMAIN}/.well-known/acme-challenge/test.txt || true
        fi
        
        log_info "清理测试文件..."
        rm -f /var/www/html/.well-known/acme-challenge/test.txt
        ;;
    *)
        main
        ;;
esac